<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab - Antonio Murrieta</title>
    <meta name="description" content="Enter Antonio's research laboratory - where innovation meets experimentation in the pursuit of digital creativity.">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Stanford-inspired palette with warmth */
            --cardinal: #8C1515;
            --cardinal-light: #B83A3A;
            --dark: #2E2D29;
            --warm-gray: #544948;
            --light-gray: #F4F4F4;
            --white: #FFFFFF;
            --accent-blue: #006CB8;
            --accent-green: #009B76;
            --accent-orange: #E98300;
            --text-primary: #2E2D29;
            --text-secondary: #544948;
            --border-light: #E5E5E5;
            --max-width: 1200px;
            --serif: 'Crimson Text', Georgia, serif;
            --sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* Import fonts for intellectual aesthetic */
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600;700&display=swap');

        ::selection {
            background: var(--cardinal);
            color: white;
        }

        body {
            font-family: var(--sans);
            background: var(--white);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 16px;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Smooth Scroll */
        html {
            scroll-behavior: smooth;
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 1000;
            padding: 24px 40px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        nav.scrolled {
            padding: 16px 40px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .nav-container {
            max-width: var(--max-width);
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.5px;
            color: var(--dark);
            text-decoration: none;
            transition: all 0.2s ease;
            position: relative;
        }

        .logo::after {
            content: '.';
            color: var(--cardinal);
            font-weight: 700;
            position: absolute;
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .logo:hover {
            color: var(--cardinal);
        }

        .nav-links {
            display: flex;
            gap: 40px;
            list-style: none;
        }

        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.2px;
            transition: all 0.2s ease;
            position: relative;
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--cardinal);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-links a:hover {
            color: var(--dark);
        }

        .nav-links a:hover::after,
        .nav-links a.active::after {
            width: 100%;
        }

        .nav-links a.active {
            color: var(--dark);
            font-weight: 600;
        }

        /* Lab Container */
        .lab-container {
            padding: 120px 40px 80px;
            min-height: 100vh;
            max-width: var(--max-width);
            margin: 0 auto;
            position: relative;
        }

        /* Lab Header */
        .lab-header {
            text-align: center;
            margin-bottom: 80px;
            animation: fadeInUp 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .lab-title {
            font-family: var(--serif);
            font-size: clamp(56px, 8vw, 88px);
            font-weight: 400;
            letter-spacing: -2px;
            margin-bottom: 32px;
            line-height: 1.1;
            color: var(--dark);
            position: relative;
        }

        .lab-title::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, var(--cardinal), var(--cardinal-light));
            border-radius: 2px;
        }

        .lab-subtitle {
            font-size: clamp(18px, 2.5vw, 22px);
            color: var(--warm-gray);
            margin-top: 40px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        .lab-subtitle::before,
        .lab-subtitle::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40px;
            height: 1px;
            background: var(--border-light);
        }

        .lab-subtitle::before {
            left: -60px;
        }

        .lab-subtitle::after {
            right: -60px;
        }

        /* Experiments Grid */
        .experiments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 40px;
            margin-bottom: 120px;
        }

        .experiment {
            background: var(--white);
            border-radius: 16px;
            padding: 40px 32px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border-light);
            box-shadow: 0 4px 16px rgba(46, 45, 41, 0.08);
            opacity: 0;
            animation: fadeIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .experiment:nth-child(1) { animation-delay: 0.1s; }
        .experiment:nth-child(2) { animation-delay: 0.2s; }
        .experiment:nth-child(3) { animation-delay: 0.3s; }
        .experiment:nth-child(4) { animation-delay: 0.4s; }
        .experiment:nth-child(5) { animation-delay: 0.5s; }
        .experiment:nth-child(6) { animation-delay: 0.6s; }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .experiment:hover {
            transform: translateY(-8px);
            box-shadow: 0 16px 40px rgba(140, 21, 21, 0.15), 0 0 0 1px var(--cardinal);
            border-color: var(--cardinal);
        }

        .experiment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--cardinal), var(--accent-blue), var(--accent-green));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .experiment:hover::before {
            transform: scaleX(1);
        }

        .experiment-icon {
            font-size: 48px;
            margin-bottom: 24px;
            display: block;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            filter: grayscale(20%);
        }

        .experiment:hover .experiment-icon {
            transform: scale(1.1) rotate(5deg);
            filter: grayscale(0%);
        }

        .experiment-title {
            font-family: var(--serif);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--dark);
            line-height: 1.2;
        }

        .experiment-description {
            font-size: 16px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0;
        }

        /* Interactive Canvas */
        .canvas-section {
            margin: 120px 0;
            text-align: center;
            padding: 60px 40px;
            background: linear-gradient(180deg, var(--white) 0%, var(--light-gray) 100%);
            border-radius: 24px;
            position: relative;
            overflow: hidden;
        }

        .canvas-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-light), transparent);
        }

        .canvas-title {
            font-family: var(--serif);
            font-size: 42px;
            font-weight: 400;
            margin-bottom: 32px;
            letter-spacing: -1px;
            color: var(--dark);
            position: relative;
        }

        .canvas-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--cardinal);
        }

        #interactive-canvas {
            border: 2px solid var(--border-light);
            background: var(--white);
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(46, 45, 41, 0.12);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #interactive-canvas:hover {
            border-color: var(--cardinal);
            box-shadow: 0 12px 40px rgba(140, 21, 21, 0.2);
        }

        .canvas-controls {
            margin-top: 40px;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }
        
        .control-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .control-group select,
        .control-group input[type="range"] {
            width: 100px;
            padding: 4px 8px;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .control-group input[type="checkbox"] {
            margin-right: 4px;
        }
        
        #interactive-canvas.grid-overlay {
            background-image: 
                linear-gradient(rgba(140, 21, 21, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(140, 21, 21, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .control-btn {
            padding: 14px 28px;
            font-size: 14px;
            font-weight: 600;
            text-decoration: none;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 2px solid var(--cardinal);
            background: transparent;
            color: var(--cardinal);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--cardinal);
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: -1;
        }

        .control-btn:hover::before {
            left: 0;
        }

        .control-btn:hover {
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(140, 21, 21, 0.25);
        }

        /* Color Palette */
        .color-palette {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 32px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid var(--border-light);
            display: inline-flex;
        }

        .color-btn {
            width: 44px;
            height: 44px;
            border: 3px solid var(--border-light);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .color-btn::after {
            content: '';
            position: absolute;
            inset: -6px;
            border: 2px solid transparent;
            border-radius: 50%;
            transition: border-color 0.3s ease;
        }

        .color-btn:hover {
            transform: scale(1.15);
            border-color: var(--cardinal);
        }

        .color-btn.active {
            transform: scale(1.2);
            border-color: var(--cardinal);
            box-shadow: 0 0 20px rgba(140, 21, 21, 0.3);
        }

        .color-btn.active::after {
            border-color: var(--cardinal);
        }

        /* Pattern Generator */
        .pattern-generator {
            margin: 120px 0;
            padding: 60px 40px;
            background: var(--white);
            border-radius: 24px;
            border: 2px solid var(--border-light);
            box-shadow: 0 8px 32px rgba(46, 45, 41, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .pattern-generator:hover {
            border-color: var(--cardinal);
            box-shadow: 0 12px 40px rgba(140, 21, 21, 0.15);
        }

        .pattern-generator h2 {
            font-family: var(--serif);
            font-size: 36px;
            font-weight: 400;
            margin-bottom: 32px;
            color: var(--dark);
            text-align: center;
            position: relative;
        }

        .pattern-generator h2::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--cardinal);
        }

        .pattern-display {
            width: 100%;
            margin: 40px 0;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            border: 2px solid var(--border-light);
            box-shadow: inset 0 4px 16px rgba(46, 45, 41, 0.06);
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--white);
        }
        
        #patternCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        #patternCanvas:hover {
            transform: scale(1.02);
        }

        /* Mobile Menu */
        .menu-toggle {
            display: none;
            flex-direction: column;
            gap: 4px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
        }

        .menu-toggle span {
            width: 25px;
            height: 2px;
            background: var(--dark);
            transition: all 0.3s ease;
        }

        .menu-toggle.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .menu-toggle.active span:nth-child(2) {
            opacity: 0;
        }

        .menu-toggle.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Dynamic Background Elements */
        .floating-gradient {
            position: fixed;
            width: 600px;
            height: 600px;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.3;
            pointer-events: none;
            animation: float-gradient 20s ease-in-out infinite;
        }

        .gradient-1 {
            background: radial-gradient(circle, var(--cardinal) 0%, transparent 70%);
            top: -300px;
            right: -300px;
        }

        .gradient-2 {
            background: radial-gradient(circle, var(--accent-blue) 0%, transparent 70%);
            bottom: -300px;
            left: -300px;
            animation-delay: -10s;
        }

        @keyframes float-gradient {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(30px, -30px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
        }

        /* Experiment Modal Overlays */
        .experiment-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(46, 45, 41, 0.95);
            backdrop-filter: blur(20px);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
        }

        .experiment-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            color: white;
        }

        .modal-title {
            font-family: var(--serif);
            font-size: clamp(32px, 5vw, 48px);
            font-weight: 400;
            margin: 0;
            color: white;
        }

        .modal-close {
            background: none;
            border: 2px solid white;
            color: white;
            font-size: 24px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: white;
            color: var(--dark);
            transform: scale(1.1);
        }

        .experiment-container {
            background: white;
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .experiment-canvas {
            width: 100%;
            height: 400px;
            border: 2px solid var(--border-light);
            border-radius: 12px;
            cursor: crosshair;
            background: white;
            display: block;
        }

        .experiment-controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 30px;
            padding: 20px;
            background: var(--light-gray);
            border-radius: 12px;
        }

        .param-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }

        .param-control label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .param-control input[type="range"] {
            width: 100px;
            accent-color: var(--cardinal);
        }

        .param-control input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
        }

        .experiment-btn {
            padding: 12px 24px;
            background: var(--cardinal);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 12px;
        }

        .experiment-btn:hover {
            background: var(--cardinal-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(140, 21, 21, 0.3);
        }

        .experiment-btn:active {
            transform: translateY(0);
        }

        /* Fractal specific styles */
        .fractal-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 10;
        }

        /* 3D Canvas styles */
        .threejs-canvas {
            border: 2px solid var(--border-light);
            border-radius: 12px;
            background: #000;
        }

        /* Responsive */
        @media (max-width: 768px) {
            nav {
                padding: 15px 20px;
            }

            .nav-links {
                position: fixed;
                top: 0;
                right: -100%;
                width: 100%;
                height: 100vh;
                background: white;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 30px;
                transition: right 0.3s ease;
                z-index: 1000;
            }

            .nav-links.active {
                right: 0;
            }

            .menu-toggle {
                display: flex;
                z-index: 1001;
            }

            .lab-container {
                padding: 120px 20px 60px;
            }

            .experiments-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .experiment {
                padding: 30px 24px;
            }

            .canvas-section {
                padding: 40px 20px;
                margin: 80px 0;
            }

            .color-palette {
                gap: 8px;
                padding: 16px;
            }

            .color-btn {
                width: 36px;
                height: 36px;
            }

            .canvas-controls {
                flex-direction: column;
                align-items: center;
                gap: 12px;
            }

            .control-btn {
                width: 200px;
                text-align: center;
            }

            #interactive-canvas {
                width: 100%;
                height: 300px;
            }

            .pattern-generator {
                padding: 40px 20px;
                margin: 80px 0;
            }

            .modal-content {
                padding: 20px;
            }

            .experiment-container {
                padding: 20px;
            }

            .experiment-canvas {
                height: 300px;
            }

            .experiment-controls {
                gap: 15px;
                padding: 15px;
            }

            .param-control {
                min-width: 100px;
            }

            .modal-header {
                margin-bottom: 20px;
            }

            .modal-close {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Dynamic Background -->
    <div class="floating-gradient gradient-1"></div>
    <div class="floating-gradient gradient-2"></div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="logo">ANTONIO MURRIETA</a>
            <ul class="nav-links" id="navLinks">
                <li><a href="index.html">HOME</a></li>
                <li><a href="work.html">WORK</a></li>
                <li><a href="library.html">LIBRARY</a></li>
                <li><a href="lab.html" class="active">LAB</a></li>
                <li><a href="story.html">STORY</a></li>
                <li><a href="connect.html">CONNECT</a></li>
            </ul>
            <button class="menu-toggle" id="menuToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <!-- Lab Container -->
    <div class="lab-container">
        <!-- Header -->
        <div class="lab-header">
            <h1 class="lab-title">Research Laboratory</h1>
            <p class="lab-subtitle">Where Innovation Meets Experimentation</p>
        </div>

        <!-- Experiments Grid -->
        <div class="experiments-grid">
            <div class="experiment" data-experiment="particles">
                <div class="experiment-icon">✨</div>
                <h3 class="experiment-title">Particle Physics</h3>
                <p class="experiment-description">Interactive particle system responding to mouse movement</p>
            </div>

            <div class="experiment" data-experiment="waves">
                <div class="experiment-icon">🌊</div>
                <h3 class="experiment-title">Wave Generator</h3>
                <p class="experiment-description">Create mesmerizing wave patterns with adjustable parameters</p>
            </div>

            <div class="experiment" data-experiment="glitch">
                <div class="experiment-icon">📺</div>
                <h3 class="experiment-title">Glitch Art</h3>
                <p class="experiment-description">Generate random glitch effects and digital distortions</p>
            </div>

            <div class="experiment" data-experiment="fractals">
                <div class="experiment-icon">🌀</div>
                <h3 class="experiment-title">Fractal Explorer</h3>
                <p class="experiment-description">Dive into infinite mathematical patterns</p>
            </div>

            <div class="experiment" data-experiment="audio">
                <div class="experiment-icon">🎵</div>
                <h3 class="experiment-title">Sound Visualizer</h3>
                <p class="experiment-description">Transform sound into visual art</p>
            </div>

            <div class="experiment" data-experiment="3d">
                <div class="experiment-icon">🎲</div>
                <h3 class="experiment-title">3D Playground</h3>
                <p class="experiment-description">Manipulate 3D objects in space</p>
            </div>
        </div>

        <!-- Interactive Canvas -->
        <div class="canvas-section">
            <h2 class="canvas-title">DRAW WITH ME</h2>
            <canvas id="interactive-canvas" width="800" height="400"></canvas>
            
            <div class="color-palette">
                <button class="color-btn active" style="background: var(--cardinal);" data-color="#8C1515"></button>
                <button class="color-btn" style="background: var(--cardinal-light);" data-color="#B83A3A"></button>
                <button class="color-btn" style="background: var(--accent-blue);" data-color="#006CB8"></button>
                <button class="color-btn" style="background: var(--accent-green);" data-color="#009B76"></button>
                <button class="color-btn" style="background: var(--accent-orange);" data-color="#E98300"></button>
                <button class="color-btn" style="background: var(--dark);" data-color="#2E2D29"></button>
                <button class="color-btn" style="background: var(--warm-gray);" data-color="#544948"></button>
            </div>

            <!-- Enhanced Canvas Controls -->
            <div class="canvas-controls">
                <div class="control-group">
                    <label>Tool:</label>
                    <select id="toolSelect">
                        <option value="brush">Brush</option>
                        <option value="eraser">Eraser</option>
                        <option value="line">Line</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Brush Type:</label>
                    <select id="brushType">
                        <option value="pen">Pen</option>
                        <option value="marker">Marker</option>
                        <option value="spray">Spray</option>
                        <option value="calligraphy">Calligraphy</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Size: <span id="brushSizeValue">3</span>px</label>
                    <input type="range" id="brushSize" min="1" max="50" value="3">
                </div>
                <div class="control-group">
                    <label>Opacity: <span id="opacityValue">100</span>%</label>
                    <input type="range" id="opacity" min="10" max="100" value="100">
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="shapeFill"> Fill
                    </label>
                    <label>
                        <input type="checkbox" id="shapeStroke" checked> Stroke
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="pressureSensitive"> Pressure
                    </label>
                    <label>
                        <input type="checkbox" id="gridToggle"> Grid
                    </label>
                </div>
            </div>
            <div class="canvas-controls">
                <button class="control-btn" id="undoBtn">Undo (Ctrl+Z)</button>
                <button class="control-btn" id="redoBtn">Redo (Ctrl+Y)</button>
                <button class="control-btn" id="clearCanvas">Clear</button>
                <button class="control-btn" id="randomPattern">Random Pattern</button>
                <button class="control-btn" id="saveArt">Save Art</button>
            </div>
        </div>

        <!-- Enhanced Pattern Generator -->
        <div class="pattern-generator">
            <h2>Pattern Generator</h2>
            <div class="pattern-display" id="patternDisplay">
                <canvas id="patternCanvas" width="600" height="300"></canvas>
            </div>
            <div class="canvas-controls">
                <div class="control-group">
                    <label>Pattern Type:</label>
                    <select id="patternType">
                        <option value="geometric">Geometric</option>
                        <option value="organic">Organic</option>
                        <option value="fractal">Fractal</option>
                        <option value="tessellation">Tessellation</option>
                        <option value="noise">Noise</option>
                        <option value="mandala">Mandala</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Complexity: <span id="complexityValue">5</span></label>
                    <input type="range" id="complexity" min="1" max="10" value="5">
                </div>
                <div class="control-group">
                    <label>Scale: <span id="scaleValue">1</span></label>
                    <input type="range" id="patternScale" min="0.1" max="3" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <label>Color Scheme:</label>
                    <select id="colorScheme">
                        <option value="stanford">Stanford</option>
                        <option value="monochrome">Monochrome</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="sunset">Sunset</option>
                        <option value="ocean">Ocean</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="patternAnimation"> Animate
                    </label>
                    <label>
                        <input type="checkbox" id="patternTileable"> Tileable
                    </label>
                </div>
            </div>
            <div class="canvas-controls">
                <button class="control-btn" id="generatePattern">Generate New</button>
                <button class="control-btn" id="exportPattern">Export PNG</button>
                <button class="control-btn" id="randomizePattern">Randomize All</button>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer style="padding: 60px 40px 40px; background: var(--dark); color: white; text-align: center;">
        <div style="max-width: var(--max-width); margin: 0 auto;">
            <div style="display: flex; gap: 30px; justify-content: center; margin-bottom: 30px; flex-wrap: wrap;">
                <a href="https://github.com/Antonio-MS-Coder" target="_blank" style="color: white; text-decoration: none; font-size: 14px; opacity: 0.8; transition: opacity 0.3s ease;">GitHub</a>
                <a href="https://linkedin.com/in/antoniomurrieta" target="_blank" style="color: white; text-decoration: none; font-size: 14px; opacity: 0.8; transition: opacity 0.3s ease;">LinkedIn</a>
                <a href="https://instagram.com/antoniomurrieta" target="_blank" style="color: white; text-decoration: none; font-size: 14px; opacity: 0.8; transition: opacity 0.3s ease;">Instagram</a>
                <a href="mailto:carlosantonio.murrieta@gmail.com" style="color: white; text-decoration: none; font-size: 14px; opacity: 0.8; transition: opacity 0.3s ease;">Email</a>
            </div>
            <p style="font-size: 13px; opacity: 0.6; margin: 0;">
                © 2024 Antonio Murrieta. Crafted with passion and code.
            </p>
        </div>
    </footer>

    <!-- Experiment Modals -->
    <!-- Particle Physics Modal -->
    <div class="experiment-modal" id="particlesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Particle Physics System</h2>
                <button class="modal-close" onclick="closeModal('particlesModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <canvas class="experiment-canvas" id="particlesCanvas"></canvas>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>Particle Count</label>
                        <input type="range" id="particleCount" min="50" max="300" value="150" onchange="updateParticles()">
                        <span id="particleCountValue">150</span>
                    </div>
                    <div class="param-control">
                        <label>Speed</label>
                        <input type="range" id="particleSpeed" min="0.5" max="3" step="0.1" value="1.5" onchange="updateParticles()">
                        <span id="particleSpeedValue">1.5</span>
                    </div>
                    <div class="param-control">
                        <label>Connection Distance</label>
                        <input type="range" id="connectionDistance" min="50" max="150" value="100" onchange="updateParticles()">
                        <span id="connectionDistanceValue">100</span>
                    </div>
                    <div class="param-control">
                        <label>Mouse Attraction</label>
                        <input type="range" id="mouseAttraction" min="0" max="100" value="50" onchange="updateParticles()">
                        <span id="mouseAttractionValue">50</span>
                    </div>
                    <button class="experiment-btn" onclick="resetParticles()">Reset</button>
                    <button class="experiment-btn" onclick="pauseParticles()" id="pauseParticlesBtn">Pause</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wave Generator Modal -->
    <div class="experiment-modal" id="wavesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Wave Generator</h2>
                <button class="modal-close" onclick="closeModal('wavesModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <canvas class="experiment-canvas" id="wavesCanvas"></canvas>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>Frequency</label>
                        <input type="range" id="waveFrequency" min="0.01" max="0.1" step="0.001" value="0.03" onchange="updateWaves()">
                        <span id="waveFrequencyValue">0.03</span>
                    </div>
                    <div class="param-control">
                        <label>Amplitude</label>
                        <input type="range" id="waveAmplitude" min="20" max="150" value="80" onchange="updateWaves()">
                        <span id="waveAmplitudeValue">80</span>
                    </div>
                    <div class="param-control">
                        <label>Speed</label>
                        <input type="range" id="waveSpeed" min="0.01" max="0.1" step="0.001" value="0.05" onchange="updateWaves()">
                        <span id="waveSpeedValue">0.05</span>
                    </div>
                    <div class="param-control">
                        <label>Wave Count</label>
                        <input type="range" id="waveCount" min="1" max="5" value="3" onchange="updateWaves()">
                        <span id="waveCountValue">3</span>
                    </div>
                    <button class="experiment-btn" onclick="randomizeWaves()">Randomize</button>
                    <button class="experiment-btn" onclick="pauseWaves()" id="pauseWavesBtn">Pause</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Glitch Art Modal -->
    <div class="experiment-modal" id="glitchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Glitch Art Generator</h2>
                <button class="modal-close" onclick="closeModal('glitchModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <canvas class="experiment-canvas" id="glitchCanvas"></canvas>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>RGB Shift</label>
                        <input type="range" id="rgbShift" min="1" max="20" value="5" onchange="updateGlitch()">
                        <span id="rgbShiftValue">5</span>
                    </div>
                    <div class="param-control">
                        <label>Scan Lines</label>
                        <input type="range" id="scanLines" min="1" max="10" value="3" onchange="updateGlitch()">
                        <span id="scanLinesValue">3</span>
                    </div>
                    <div class="param-control">
                        <label>Noise Level</label>
                        <input type="range" id="noiseLevel" min="0.1" max="1" step="0.1" value="0.3" onchange="updateGlitch()">
                        <span id="noiseLevelValue">0.3</span>
                    </div>
                    <div class="param-control">
                        <label>Pixel Sort</label>
                        <input type="range" id="pixelSort" min="0" max="100" value="20" onchange="updateGlitch()">
                        <span id="pixelSortValue">20</span>
                    </div>
                    <button class="experiment-btn" onclick="generateNewGlitch()">Generate New</button>
                    <button class="experiment-btn" onclick="saveGlitch()">Save Glitch</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Fractal Explorer Modal -->
    <div class="experiment-modal" id="fractalsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Fractal Explorer</h2>
                <button class="modal-close" onclick="closeModal('fractalsModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <div style="position: relative;">
                    <canvas class="experiment-canvas" id="fractalsCanvas"></canvas>
                    <div class="fractal-info" id="fractalInfo">
                        Zoom: 1x | Iterations: 100<br>
                        Click to zoom in | Right-click to zoom out
                    </div>
                </div>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>Max Iterations</label>
                        <input type="range" id="maxIterations" min="50" max="500" value="100" onchange="updateFractals()">
                        <span id="maxIterationsValue">100</span>
                    </div>
                    <div class="param-control">
                        <label>Color Palette</label>
                        <select id="colorPalette" onchange="updateFractals()">
                            <option value="cardinal">Cardinal</option>
                            <option value="rainbow">Rainbow</option>
                            <option value="blue">Ocean Blue</option>
                            <option value="fire">Fire</option>
                        </select>
                    </div>
                    <div class="param-control">
                        <label>Fractal Type</label>
                        <select id="fractalType" onchange="updateFractals()">
                            <option value="mandelbrot">Mandelbrot</option>
                            <option value="julia">Julia Set</option>
                        </select>
                    </div>
                    <button class="experiment-btn" onclick="resetFractal()">Reset View</button>
                    <button class="experiment-btn" onclick="saveFractal()">Save Image</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Visualizer Modal -->
    <div class="experiment-modal" id="audioModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Sound Visualizer</h2>
                <button class="modal-close" onclick="closeModal('audioModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <canvas class="experiment-canvas" id="audioCanvas"></canvas>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>Visualization</label>
                        <select id="visualizationType" onchange="updateAudioVisualizer()">
                            <option value="bars">Frequency Bars</option>
                            <option value="circular">Circular</option>
                            <option value="waveform">Waveform</option>
                            <option value="particles">Particle Field</option>
                        </select>
                    </div>
                    <div class="param-control">
                        <label>Sensitivity</label>
                        <input type="range" id="audioSensitivity" min="1" max="5" step="0.5" value="2" onchange="updateAudioVisualizer()">
                        <span id="audioSensitivityValue">2</span>
                    </div>
                    <div class="param-control">
                        <label>Smoothing</label>
                        <input type="range" id="audioSmoothing" min="0" max="0.9" step="0.1" value="0.5" onchange="updateAudioVisualizer()">
                        <span id="audioSmoothingValue">0.5</span>
                    </div>
                    <button class="experiment-btn" onclick="startAudioCapture()" id="audioToggleBtn">Start Microphone</button>
                    <button class="experiment-btn" onclick="generateTestTone()">Test Tone</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D Playground Modal -->
    <div class="experiment-modal" id="3dModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">3D Playground</h2>
                <button class="modal-close" onclick="closeModal('3dModal')">&times;</button>
            </div>
            <div class="experiment-container">
                <div id="threejsContainer" style="width: 100%; height: 400px; border: 2px solid var(--border-light); border-radius: 12px; background: #000;"></div>
                <div class="experiment-controls">
                    <div class="param-control">
                        <label>Shape</label>
                        <select id="shapeType" onchange="update3DScene()">
                            <option value="cube">Cube</option>
                            <option value="sphere">Sphere</option>
                            <option value="torus">Torus</option>
                            <option value="icosahedron">Icosahedron</option>
                            <option value="multiple">Multiple Shapes</option>
                        </select>
                    </div>
                    <div class="param-control">
                        <label>Rotation Speed</label>
                        <input type="range" id="rotationSpeed" min="0" max="0.1" step="0.001" value="0.01" onchange="update3DScene()">
                        <span id="rotationSpeedValue">0.01</span>
                    </div>
                    <div class="param-control">
                        <label>Wireframe</label>
                        <input type="checkbox" id="wireframeMode" onchange="update3DScene()">
                    </div>
                    <div class="param-control">
                        <label>Color</label>
                        <select id="shapeColor" onchange="update3DScene()">
                            <option value="cardinal">Cardinal Red</option>
                            <option value="blue">Stanford Blue</option>
                            <option value="green">Forest Green</option>
                            <option value="rainbow">Rainbow</option>
                        </select>
                    </div>
                    <button class="experiment-btn" onclick="reset3DScene()">Reset Camera</button>
                    <button class="experiment-btn" onclick="randomize3DScene()">Randomize</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Navigation scroll effect
        const navbar = document.querySelector('nav');

        window.addEventListener('scroll', () => {
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });

        // Interactive Canvas - Enhanced Draw with Me
        const canvas = document.getElementById('interactive-canvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentColor = '#8C1515';
        let currentBrushSize = 3;
        let currentOpacity = 1.0;
        let currentBrushType = 'pen';
        let currentTool = 'brush';
        let isErasing = false;
        let lastX = 0;
        let lastY = 0;
        let undoStack = [];
        let redoStack = [];
        let isGridVisible = false;
        let isPressureSensitive = false;
        
        // Shape drawing state
        let isDrawingShape = false;
        let shapeStartX = 0;
        let shapeStartY = 0;
        let currentShape = 'line';
        let shapeFill = false;
        let shapeStroke = true;
        
        // Pressure simulation
        let mouseSpeed = 0;
        let lastMouseTime = 0;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Resize canvas for mobile
        function resizeCanvas() {
            if (window.innerWidth < 768) {
                canvas.width = window.innerWidth - 40;
                canvas.height = 300;
            }
            saveCanvasState(); // Save state after resize
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Canvas state management
        function saveCanvasState() {
            if (undoStack.length > 50) undoStack.shift(); // Limit stack size
            undoStack.push(canvas.toDataURL());
            redoStack = []; // Clear redo stack when new action is performed
        }
        
        function undo() {
            if (undoStack.length > 1) {
                redoStack.push(undoStack.pop());
                const previousState = undoStack[undoStack.length - 1];
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = previousState;
            }
        }
        
        function redo() {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                undoStack.push(nextState);
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = nextState;
            }
        }
        
        // Enhanced drawing functions
        function calculatePressure(speed) {
            if (!isPressureSensitive) return 1;
            return Math.max(0.1, Math.min(1, 1 - (speed / 2000)));
        }
        
        function getEffectiveBrushSize(pressure = 1) {
            return currentBrushSize * pressure;
        }
        
        function drawSpray(x, y, size, opacity) {
            const density = Math.floor(size * 2);
            for (let i = 0; i < density; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * size;
                const sprayX = x + Math.cos(angle) * radius;
                const sprayY = y + Math.sin(angle) * radius;
                
                ctx.globalAlpha = opacity * Math.random() * 0.5;
                ctx.fillStyle = currentColor;
                ctx.beginPath();
                ctx.arc(sprayX, sprayY, Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawCalligraphy(x1, y1, x2, y2, size, opacity) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const length = Math.sqrt(dx * dx + dy * dy);
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            
            // Create calligraphy effect by varying width
            const steps = Math.max(1, Math.floor(length / 2));
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + dx * t;
                const y = y1 + dy * t;
                const width = size * (0.5 + 0.5 * Math.sin(t * Math.PI));
                
                ctx.lineWidth = width;
                if (i === 0) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawMarker(x1, y1, x2, y2, size, opacity) {
            ctx.save();
            ctx.globalAlpha = opacity * 0.7;
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = size * 1.5;
            ctx.lineCap = 'square';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }
        
        function drawShape(x1, y1, x2, y2, shape) {
            ctx.save();
            ctx.globalAlpha = currentOpacity;
            
            if (shapeStroke) {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
            }
            
            if (shapeFill) {
                ctx.fillStyle = currentColor;
            }
            
            switch(shape) {
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    if (shapeStroke) ctx.stroke();
                    break;
                    
                case 'rectangle':
                    const width = x2 - x1;
                    const height = y2 - y1;
                    if (shapeFill) ctx.fillRect(x1, y1, width, height);
                    if (shapeStroke) ctx.strokeRect(x1, y1, width, height);
                    break;
                    
                case 'circle':
                    const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    ctx.beginPath();
                    ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
                    if (shapeFill) ctx.fill();
                    if (shapeStroke) ctx.stroke();
                    break;
            }
            
            ctx.restore();
        }
        
        // Initialize canvas state
        saveCanvasState();

        // Enhanced Drawing functionality
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (['line', 'rectangle', 'circle'].includes(currentTool)) {
                isDrawingShape = true;
                shapeStartX = x;
                shapeStartY = y;
                saveCanvasState(); // Save state before shape drawing
            } else {
                isDrawing = true;
                lastX = x;
                lastY = y;
                
                // Calculate initial mouse speed
                const now = Date.now();
                if (lastMouseTime > 0) {
                    const timeDiff = now - lastMouseTime;
                    const distance = Math.sqrt(Math.pow(x - lastMouseX, 2) + Math.pow(y - lastMouseY, 2));
                    mouseSpeed = distance / timeDiff;
                } else {
                    mouseSpeed = 0;
                }
                lastMouseTime = now;
                lastMouseX = x;
                lastMouseY = y;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Update mouse speed for pressure calculation
            const now = Date.now();
            if (lastMouseTime > 0) {
                const timeDiff = now - lastMouseTime;
                const distance = Math.sqrt(Math.pow(x - lastMouseX, 2) + Math.pow(y - lastMouseY, 2));
                mouseSpeed = distance / (timeDiff || 1);
            }
            lastMouseTime = now;
            lastMouseX = x;
            lastMouseY = y;
            
            if (isDrawingShape) {
                // Preview shape while drawing
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    // Draw preview shape
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    drawShape(shapeStartX, shapeStartY, x, y, currentTool);
                    ctx.restore();
                };
                img.src = undoStack[undoStack.length - 1];
                return;
            }
            
            if (!isDrawing) return;
            
            const pressure = calculatePressure(mouseSpeed);
            const effectiveSize = getEffectiveBrushSize(pressure);
            const effectiveOpacity = currentOpacity * (isPressureSensitive ? pressure : 1);
            
            switch(currentBrushType) {
                case 'pen':
                    ctx.globalAlpha = effectiveOpacity;
                    ctx.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;
                    ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                    ctx.lineWidth = effectiveSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // Add subtle glow effect
                    if (currentTool !== 'eraser') {
                        ctx.shadowBlur = Math.max(1, effectiveSize / 3);
                        ctx.shadowColor = currentColor;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    break;
                    
                case 'marker':
                    drawMarker(lastX, lastY, x, y, effectiveSize, effectiveOpacity);
                    break;
                    
                case 'spray':
                    drawSpray(x, y, effectiveSize, effectiveOpacity);
                    break;
                    
                case 'calligraphy':
                    drawCalligraphy(lastX, lastY, x, y, effectiveSize, effectiveOpacity);
                    break;
            }
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            
            lastX = x;
            lastY = y;
        });

        canvas.addEventListener('mouseup', () => {
            if (isDrawingShape) {
                const rect = canvas.getBoundingClientRect();
                const currentMouseX = event.clientX - rect.left;
                const currentMouseY = event.clientY - rect.top;
                
                // Restore canvas state and draw final shape
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    drawShape(shapeStartX, shapeStartY, currentMouseX, currentMouseY, currentTool);
                    saveCanvasState();
                };
                img.src = undoStack[undoStack.length - 1];
                
                isDrawingShape = false;
            } else if (isDrawing) {
                isDrawing = false;
                saveCanvasState();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState();
            }
            if (isDrawingShape) {
                isDrawingShape = false;
            }
        });

        // Enhanced Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (['line', 'rectangle', 'circle'].includes(currentTool)) {
                isDrawingShape = true;
                shapeStartX = x;
                shapeStartY = y;
                saveCanvasState();
            } else {
                isDrawing = true;
                lastX = x;
                lastY = y;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (isDrawingShape) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    drawShape(shapeStartX, shapeStartY, x, y, currentTool);
                    ctx.restore();
                };
                img.src = undoStack[undoStack.length - 1];
                return;
            }
            
            if (!isDrawing) return;
            
            const effectiveSize = currentBrushSize;
            const effectiveOpacity = currentOpacity;
            
            switch(currentBrushType) {
                case 'pen':
                    ctx.globalAlpha = effectiveOpacity;
                    ctx.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;
                    ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                    ctx.lineWidth = effectiveSize;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    break;
                    
                case 'marker':
                    drawMarker(lastX, lastY, x, y, effectiveSize, effectiveOpacity);
                    break;
                    
                case 'spray':
                    drawSpray(x, y, effectiveSize, effectiveOpacity);
                    break;
                    
                case 'calligraphy':
                    drawCalligraphy(lastX, lastY, x, y, effectiveSize, effectiveOpacity);
                    break;
            }
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            
            lastX = x;
            lastY = y;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isDrawingShape) {
                const rect = canvas.getBoundingClientRect();
                const lastTouch = e.changedTouches[0];
                const currentTouchX = lastTouch.clientX - rect.left;
                const currentTouchY = lastTouch.clientY - rect.top;
                
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    drawShape(shapeStartX, shapeStartY, currentTouchX, currentTouchY, currentTool);
                    saveCanvasState();
                };
                img.src = undoStack[undoStack.length - 1];
                
                isDrawingShape = false;
            } else if (isDrawing) {
                isDrawing = false;
                saveCanvasState();
            }
        });

        // Enhanced Control Event Handlers
        
        // Tool selection
        document.getElementById('toolSelect').addEventListener('change', (e) => {
            currentTool = e.target.value;
            canvas.style.cursor = currentTool === 'eraser' ? 'grabbing' : 'crosshair';
        });
        
        // Brush type selection
        document.getElementById('brushType').addEventListener('change', (e) => {
            currentBrushType = e.target.value;
        });
        
        // Brush size control
        document.getElementById('brushSize').addEventListener('input', (e) => {
            currentBrushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = currentBrushSize;
        });
        
        // Opacity control
        document.getElementById('opacity').addEventListener('input', (e) => {
            currentOpacity = parseInt(e.target.value) / 100;
            document.getElementById('opacityValue').textContent = e.target.value;
        });
        
        // Shape fill/stroke options
        document.getElementById('shapeFill').addEventListener('change', (e) => {
            shapeFill = e.target.checked;
        });
        
        document.getElementById('shapeStroke').addEventListener('change', (e) => {
            shapeStroke = e.target.checked;
        });
        
        // Pressure sensitivity toggle
        document.getElementById('pressureSensitive').addEventListener('change', (e) => {
            isPressureSensitive = e.target.checked;
        });
        
        // Grid toggle
        document.getElementById('gridToggle').addEventListener('change', (e) => {
            isGridVisible = e.target.checked;
            canvas.classList.toggle('grid-overlay', isGridVisible);
        });
        
        // Undo/Redo buttons
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        // Color palette
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentColor = btn.dataset.color;
            });
        });

        // Canvas controls
        document.getElementById('clearCanvas').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveCanvasState();
        });

        document.getElementById('randomPattern').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const colors = ['#8C1515', '#B83A3A', '#006CB8', '#009B76', '#E98300', '#2E2D29'];
            
            for (let i = 0; i < 50; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 30 + 5,
                    0,
                    Math.PI * 2
                );
                ctx.strokeStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.lineWidth = Math.random() * 3 + 1;
                ctx.stroke();
            }
        });

        document.getElementById('saveArt').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'lab-art.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        // Enhanced Pattern Generator
        let patternSystem = null;
        
        function initPatternGenerator() {
            const canvas = document.getElementById('patternCanvas');
            const ctx = canvas.getContext('2d');
            let animationId = null;
            let animationTime = 0;
            
            // Color schemes
            const colorSchemes = {
                stanford: ['#8C1515', '#B83A3A', '#006CB8', '#009B76', '#E98300', '#2E2D29'],
                monochrome: ['#000000', '#333333', '#666666', '#999999', '#CCCCCC', '#FFFFFF'],
                rainbow: ['#FF0000', '#FF8000', '#FFFF00', '#80FF00', '#00FF00', '#00FF80', '#00FFFF', '#0080FF', '#0000FF', '#8000FF', '#FF00FF', '#FF0080'],
                sunset: ['#FF6B35', '#F7931E', '#FFD23F', '#06FFA5', '#118AB2', '#073B4C'],
                ocean: ['#264653', '#2A9D8F', '#E9C46A', '#F4A261', '#E76F51', '#E63946']
            };
            
            function getColors() {
                const scheme = document.getElementById('colorScheme').value;
                return colorSchemes[scheme] || colorSchemes.stanford;
            }
            
            function drawGeometric(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < complexity * 3; i++) {
                    const angle = (i / (complexity * 3)) * Math.PI * 2 + time * 0.01;
                    const radius = 50 + (i * 15) * scale;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.globalAlpha = 0.7;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + time * 0.02);
                    
                    if (i % 3 === 0) {
                        ctx.fillRect(-10 * scale, -10 * scale, 20 * scale, 20 * scale);
                    } else if (i % 3 === 1) {
                        ctx.beginPath();
                        ctx.arc(0, 0, 10 * scale, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(0, -15 * scale);
                        ctx.lineTo(-13 * scale, 7.5 * scale);
                        ctx.lineTo(13 * scale, 7.5 * scale);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }
            
            function drawOrganic(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < complexity * 5; i++) {
                    const x = (Math.sin(i + time * 0.001) + 1) * canvas.width / 2;
                    const y = (Math.cos(i * 0.8 + time * 0.0015) + 1) * canvas.height / 2;
                    const size = (Math.sin(i * 0.5 + time * 0.002) + 1) * 20 * scale + 10;
                    
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.globalAlpha = 0.6;
                    
                    ctx.beginPath();
                    for (let j = 0; j < 12; j++) {
                        const angle = (j / 12) * Math.PI * 2;
                        const r = size + Math.sin(j * 3 + time * 0.01) * size * 0.3;
                        const px = x + Math.cos(angle) * r;
                        const py = y + Math.sin(angle) * r;
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            function drawFractal(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                function sierpinski(x1, y1, x2, y2, x3, y3, depth) {
                    if (depth === 0) {
                        ctx.fillStyle = colors[depth % colors.length];
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.lineTo(x3, y3);
                        ctx.closePath();
                        ctx.fill();
                        return;
                    }
                    
                    const mx1 = (x1 + x2) / 2;
                    const my1 = (y1 + y2) / 2;
                    const mx2 = (x2 + x3) / 2;
                    const my2 = (y2 + y3) / 2;
                    const mx3 = (x3 + x1) / 2;
                    const my3 = (y3 + y1) / 2;
                    
                    sierpinski(x1, y1, mx1, my1, mx3, my3, depth - 1);
                    sierpinski(mx1, my1, x2, y2, mx2, my2, depth - 1);
                    sierpinski(mx3, my3, mx2, my2, x3, y3, depth - 1);
                }
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const size = 150 * scale;
                
                sierpinski(
                    centerX, centerY - size,
                    centerX - size, centerY + size,
                    centerX + size, centerY + size,
                    Math.min(complexity, 6)
                );
                ctx.globalAlpha = 1;
            }
            
            function drawMandala(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let layer = 0; layer < complexity; layer++) {
                    const radius = (layer + 1) * 20 * scale;
                    const segments = (layer + 1) * 6;
                    
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2 + time * 0.005;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        ctx.fillStyle = colors[(layer + i) % colors.length];
                        ctx.globalAlpha = 0.7;
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle + time * 0.01);
                        
                        // Draw petal shape
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 8 * scale, 15 * scale, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
                ctx.globalAlpha = 1;
            }
            
            function drawTessellation(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const tileSize = 30 * scale;
                const cols = Math.ceil(canvas.width / tileSize) + 1;
                const rows = Math.ceil(canvas.height / tileSize) + 1;
                
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const x = i * tileSize;
                        const y = j * tileSize;
                        const offset = (i + j) % 2 ? tileSize / 2 : 0;
                        
                        ctx.fillStyle = colors[(i + j + Math.floor(time * 0.01)) % colors.length];
                        ctx.globalAlpha = 0.8;
                        
                        ctx.save();
                        ctx.translate(x + tileSize/2, y + tileSize/2 + offset);
                        ctx.rotate(time * 0.002 + (i + j) * 0.1);
                        
                        // Draw hexagon
                        ctx.beginPath();
                        for (let k = 0; k < 6; k++) {
                            const angle = (k / 6) * Math.PI * 2;
                            const px = Math.cos(angle) * tileSize * 0.4;
                            const py = Math.sin(angle) * tileSize * 0.4;
                            
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
                ctx.globalAlpha = 1;
            }
            
            function drawNoise(time = 0) {
                const colors = getColors();
                const complexity = parseInt(document.getElementById('complexity').value);
                const scale = parseFloat(document.getElementById('patternScale').value);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const x = (i / 4) % canvas.width;
                    const y = Math.floor((i / 4) / canvas.width);
                    
                    // Simple noise function
                    const noise = Math.sin(x * 0.01 * complexity + time * 0.001) * 
                                 Math.cos(y * 0.01 * complexity + time * 0.0015) * 
                                 Math.sin((x + y) * 0.005 * complexity + time * 0.002);
                    
                    const colorIndex = Math.floor((noise + 1) * 0.5 * colors.length);
                    const color = colors[Math.abs(colorIndex) % colors.length];
                    
                    // Convert hex to RGB
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                    data[i + 3] = 255 * 0.8; // Alpha
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            function render(time = 0) {
                const patternType = document.getElementById('patternType').value;
                
                switch(patternType) {
                    case 'geometric':
                        drawGeometric(time);
                        break;
                    case 'organic':
                        drawOrganic(time);
                        break;
                    case 'fractal':
                        drawFractal(time);
                        break;
                    case 'mandala':
                        drawMandala(time);
                        break;
                    case 'tessellation':
                        drawTessellation(time);
                        break;
                    case 'noise':
                        drawNoise(time);
                        break;
                    default:
                        drawGeometric(time);
                }
            }
            
            function animate() {
                animationTime++;
                render(animationTime);
                if (document.getElementById('patternAnimation').checked) {
                    animationId = requestAnimationFrame(animate);
                }
            }
            
            patternSystem = {
                render: () => render(animationTime),
                startAnimation: () => {
                    if (!animationId && document.getElementById('patternAnimation').checked) {
                        animate();
                    }
                },
                stopAnimation: () => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                },
                export: () => {
                    const link = document.createElement('a');
                    link.download = `pattern-${Date.now()}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                },
                randomize: () => {
                    const patterns = ['geometric', 'organic', 'fractal', 'mandala', 'tessellation', 'noise'];
                    const schemes = ['stanford', 'monochrome', 'rainbow', 'sunset', 'ocean'];
                    
                    document.getElementById('patternType').value = patterns[Math.floor(Math.random() * patterns.length)];
                    document.getElementById('colorScheme').value = schemes[Math.floor(Math.random() * schemes.length)];
                    document.getElementById('complexity').value = Math.floor(Math.random() * 10) + 1;
                    document.getElementById('patternScale').value = (Math.random() * 2.9 + 0.1).toFixed(1);
                    
                    // Update display values
                    document.getElementById('complexityValue').textContent = document.getElementById('complexity').value;
                    document.getElementById('scaleValue').textContent = document.getElementById('patternScale').value;
                    
                    render(animationTime);
                }
            };
            
            // Initial render
            render();
        }

        // Initialize pattern generator
        initPatternGenerator();

        // Pattern Generator Event Handlers
        document.getElementById('generatePattern').addEventListener('click', () => {
            if (patternSystem) patternSystem.render();
        });
        
        document.getElementById('exportPattern').addEventListener('click', () => {
            if (patternSystem) patternSystem.export();
        });
        
        document.getElementById('randomizePattern').addEventListener('click', () => {
            if (patternSystem) patternSystem.randomize();
        });
        
        document.getElementById('patternType').addEventListener('change', () => {
            if (patternSystem) patternSystem.render();
        });
        
        document.getElementById('colorScheme').addEventListener('change', () => {
            if (patternSystem) patternSystem.render();
        });
        
        document.getElementById('complexity').addEventListener('input', (e) => {
            document.getElementById('complexityValue').textContent = e.target.value;
            if (patternSystem) patternSystem.render();
        });
        
        document.getElementById('patternScale').addEventListener('input', (e) => {
            document.getElementById('scaleValue').textContent = e.target.value;
            if (patternSystem) patternSystem.render();
        });
        
        document.getElementById('patternAnimation').addEventListener('change', (e) => {
            if (patternSystem) {
                if (e.target.checked) {
                    patternSystem.startAnimation();
                } else {
                    patternSystem.stopAnimation();
                }
            }
        });


        // Modal System
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Initialize the specific experiment when opened
            switch(modalId) {
                case 'particlesModal':
                    initParticles();
                    break;
                case 'wavesModal':
                    initWaves();
                    break;
                case 'glitchModal':
                    initGlitch();
                    break;
                case 'fractalsModal':
                    initFractals();
                    break;
                case 'audioModal':
                    initAudioVisualizer();
                    break;
                case '3dModal':
                    init3DScene();
                    break;
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            document.body.style.overflow = '';
            
            // Cleanup the specific experiment when closed
            switch(modalId) {
                case 'particlesModal':
                    stopParticles();
                    break;
                case 'wavesModal':
                    stopWaves();
                    break;
                case 'audioModal':
                    stopAudioCapture();
                    break;
                case '3dModal':
                    cleanup3DScene();
                    break;
            }
        }

        // Experiment cards interaction
        document.querySelectorAll('.experiment').forEach(card => {
            card.addEventListener('click', () => {
                const experiment = card.dataset.experiment;
                openModal(experiment + 'Modal');
            });
        });

        // PARTICLE PHYSICS EXPERIMENT
        let particleSystem = null;

        function initParticles() {
            const canvas = document.getElementById('particlesCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const particles = [];
            let animationId;
            let mouseX = 0;
            let mouseY = 0;
            let isPaused = false;

            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 3 + 1;
                    this.originalVx = this.vx;
                    this.originalVy = this.vy;
                }

                update() {
                    const speed = parseFloat(document.getElementById('particleSpeed').value);
                    const mouseAttraction = parseFloat(document.getElementById('mouseAttraction').value) / 1000;
                    
                    // Mouse attraction
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 100) {
                        this.vx += dx * mouseAttraction;
                        this.vy += dy * mouseAttraction;
                    }
                    
                    // Apply speed multiplier
                    this.x += this.vx * speed;
                    this.y += this.vy * speed;
                    
                    // Bounce off walls
                    if (this.x < 0 || this.x > canvas.width) {
                        this.vx = -this.vx;
                        this.x = Math.max(0, Math.min(canvas.width, this.x));
                    }
                    if (this.y < 0 || this.y > canvas.height) {
                        this.vy = -this.vy;
                        this.y = Math.max(0, Math.min(canvas.height, this.y));
                    }
                    
                    // Apply friction
                    this.vx *= 0.99;
                    this.vy *= 0.99;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#8C1515';
                    ctx.fill();
                    
                    // Glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8C1515';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            function createParticles() {
                const count = parseInt(document.getElementById('particleCount').value);
                particles.length = 0;
                for (let i = 0; i < count; i++) {
                    particles.push(new Particle());
                }
            }

            function drawConnections() {
                const connectionDistance = parseInt(document.getElementById('connectionDistance').value);
                ctx.strokeStyle = 'rgba(140, 21, 21, 0.2)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < connectionDistance) {
                            const opacity = 1 - (distance / connectionDistance);
                            ctx.strokeStyle = `rgba(140, 21, 21, ${opacity * 0.5})`;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                if (!isPaused) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Update and draw particles
                    particles.forEach(particle => {
                        particle.update();
                        particle.draw();
                    });
                    
                    // Draw connections
                    drawConnections();
                }
                
                animationId = requestAnimationFrame(animate);
            }

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });

            createParticles();
            animate();

            particleSystem = {
                particles,
                animationId,
                createParticles,
                isPaused: () => isPaused,
                pause: () => { isPaused = !isPaused; },
                stop: () => { 
                    cancelAnimationFrame(animationId);
                    particles.length = 0;
                }
            };
        }

        function updateParticles() {
            if (particleSystem) {
                particleSystem.createParticles();
            }
            // Update display values
            document.getElementById('particleCountValue').textContent = document.getElementById('particleCount').value;
            document.getElementById('particleSpeedValue').textContent = document.getElementById('particleSpeed').value;
            document.getElementById('connectionDistanceValue').textContent = document.getElementById('connectionDistance').value;
            document.getElementById('mouseAttractionValue').textContent = document.getElementById('mouseAttraction').value;
        }

        function resetParticles() {
            if (particleSystem) {
                particleSystem.createParticles();
            }
        }

        function pauseParticles() {
            if (particleSystem) {
                particleSystem.pause();
                document.getElementById('pauseParticlesBtn').textContent = particleSystem.isPaused() ? 'Resume' : 'Pause';
            }
        }

        function stopParticles() {
            if (particleSystem) {
                particleSystem.stop();
                particleSystem = null;
            }
        }

        // WAVE GENERATOR EXPERIMENT
        let waveSystem = null;

        function initWaves() {
            const canvas = document.getElementById('wavesCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            let animationId;
            let time = 0;
            let isPaused = false;

            function drawWave(offset, color, alpha = 1) {
                const frequency = parseFloat(document.getElementById('waveFrequency').value);
                const amplitude = parseFloat(document.getElementById('waveAmplitude').value);
                const speed = parseFloat(document.getElementById('waveSpeed').value);
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.globalAlpha = alpha;
                ctx.lineWidth = 2;
                
                for (let x = 0; x <= canvas.width; x += 2) {
                    const y = canvas.height / 2 + Math.sin((x * frequency) + (time * speed) + offset) * amplitude;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            function animate() {
                if (!isPaused) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, 'rgba(140, 21, 21, 0.05)');
                    gradient.addColorStop(0.5, 'rgba(0, 107, 184, 0.05)');
                    gradient.addColorStop(1, 'rgba(0, 155, 118, 0.05)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const waveCount = parseInt(document.getElementById('waveCount').value);
                    const colors = ['#8C1515', '#006CB8', '#009B76', '#E98300', '#B83A3A'];
                    
                    for (let i = 0; i < waveCount; i++) {
                        const offset = (i * Math.PI * 2) / waveCount;
                        const alpha = 0.8 - (i * 0.1);
                        drawWave(offset, colors[i % colors.length], alpha);
                    }
                    
                    time += 1;
                }
                
                animationId = requestAnimationFrame(animate);
            }

            animate();

            waveSystem = {
                animationId,
                isPaused: () => isPaused,
                pause: () => { isPaused = !isPaused; },
                stop: () => { cancelAnimationFrame(animationId); }
            };
        }

        function updateWaves() {
            // Update display values
            document.getElementById('waveFrequencyValue').textContent = document.getElementById('waveFrequency').value;
            document.getElementById('waveAmplitudeValue').textContent = document.getElementById('waveAmplitude').value;
            document.getElementById('waveSpeedValue').textContent = document.getElementById('waveSpeed').value;
            document.getElementById('waveCountValue').textContent = document.getElementById('waveCount').value;
        }

        function randomizeWaves() {
            document.getElementById('waveFrequency').value = (Math.random() * 0.09 + 0.01).toFixed(3);
            document.getElementById('waveAmplitude').value = Math.floor(Math.random() * 130 + 20);
            document.getElementById('waveSpeed').value = (Math.random() * 0.09 + 0.01).toFixed(3);
            document.getElementById('waveCount').value = Math.floor(Math.random() * 4 + 1);
            updateWaves();
        }

        function pauseWaves() {
            if (waveSystem) {
                waveSystem.pause();
                document.getElementById('pauseWavesBtn').textContent = waveSystem.isPaused() ? 'Resume' : 'Pause';
            }
        }

        function stopWaves() {
            if (waveSystem) {
                waveSystem.stop();
                waveSystem = null;
            }
        }

        // GLITCH ART EXPERIMENT
        let glitchSystem = null;

        function initGlitch() {
            const canvas = document.getElementById('glitchCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Create base image
            createBaseImage();
            generateNewGlitch();

            function createBaseImage() {
                // Create a colorful base pattern
                const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
                gradient.addColorStop(0, '#8C1515');
                gradient.addColorStop(0.3, '#006CB8');
                gradient.addColorStop(0.6, '#009B76');
                gradient.addColorStop(1, '#E98300');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add some geometric shapes
                ctx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 100 + 50;
                    ctx.fillRect(x, y, size, size);
                }
                
                ctx.beginPath();
                ctx.strokeStyle = '#2E2D29';
                ctx.lineWidth = 5;
                for (let i = 0; i < 10; i++) {
                    ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.lineTo(Math.random() * canvas.width, Math.random() * canvas.height);
                }
                ctx.stroke();
            }

            glitchSystem = { canvas, ctx, createBaseImage };
        }

        function generateNewGlitch() {
            if (!glitchSystem) return;
            
            const { canvas, ctx, createBaseImage } = glitchSystem;
            
            // Recreate base image
            createBaseImage();
            
            // Get original image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const rgbShift = parseInt(document.getElementById('rgbShift').value);
            const scanLines = parseInt(document.getElementById('scanLines').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            const pixelSort = parseInt(document.getElementById('pixelSort').value);
            
            // Apply RGB shift
            applyRGBShift(data, canvas.width, canvas.height, rgbShift);
            
            // Apply scan lines
            applyScanLines(data, canvas.width, canvas.height, scanLines);
            
            // Apply noise
            applyNoise(data, noiseLevel);
            
            // Apply pixel sorting effect
            if (pixelSort > 0) {
                applyPixelSort(data, canvas.width, canvas.height, pixelSort);
            }
            
            // Apply the modified data back to canvas
            ctx.putImageData(imageData, 0, 0);
        }

        function applyRGBShift(data, width, height, shift) {
            const shiftedData = new Uint8ClampedArray(data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Red channel shift
                    const redShiftX = Math.max(0, Math.min(width - 1, x + shift));
                    const redIdx = (y * width + redShiftX) * 4;
                    data[idx] = shiftedData[redIdx];
                    
                    // Blue channel shift
                    const blueShiftX = Math.max(0, Math.min(width - 1, x - shift));
                    const blueIdx = (y * width + blueShiftX) * 4;
                    data[idx + 2] = shiftedData[blueIdx + 2];
                }
            }
        }

        function applyScanLines(data, width, height, intensity) {
            for (let y = 0; y < height; y += intensity) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    data[idx] = Math.max(0, data[idx] - 50);     // Red
                    data[idx + 1] = Math.max(0, data[idx + 1] - 50); // Green
                    data[idx + 2] = Math.max(0, data[idx + 2] - 50); // Blue
                }
            }
        }

        function applyNoise(data, level) {
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < level) {
                    const noise = (Math.random() - 0.5) * 100;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
            }
        }

        function applyPixelSort(data, width, height, intensity) {
            // Sort pixels in horizontal strips
            for (let y = 0; y < height; y += Math.floor(100 / intensity)) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    row.push({
                        r: data[idx],
                        g: data[idx + 1],
                        b: data[idx + 2],
                        a: data[idx + 3],
                        brightness: (data[idx] + data[idx + 1] + data[idx + 2]) / 3
                    });
                }
                
                // Sort by brightness
                row.sort((a, b) => a.brightness - b.brightness);
                
                // Put sorted pixels back
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    data[idx] = row[x].r;
                    data[idx + 1] = row[x].g;
                    data[idx + 2] = row[x].b;
                    data[idx + 3] = row[x].a;
                }
            }
        }

        function updateGlitch() {
            document.getElementById('rgbShiftValue').textContent = document.getElementById('rgbShift').value;
            document.getElementById('scanLinesValue').textContent = document.getElementById('scanLines').value;
            document.getElementById('noiseLevelValue').textContent = document.getElementById('noiseLevel').value;
            document.getElementById('pixelSortValue').textContent = document.getElementById('pixelSort').value;
            
            generateNewGlitch();
        }

        function saveGlitch() {
            if (glitchSystem) {
                const link = document.createElement('a');
                link.download = 'glitch-art.png';
                link.href = glitchSystem.canvas.toDataURL();
                link.click();
            }
        }

        // ENHANCED FRACTAL EXPLORER EXPERIMENT
        let fractalSystem = null;

        function initFractals() {
            const canvas = document.getElementById('fractalsCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            let centerX = -0.5;
            let centerY = 0;
            let zoom = 1;
            let maxIterations = 100;
            let juliaC = { real: -0.7, imag: 0.27015 };
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let lastCenterX = centerX;
            let lastCenterY = centerY;

            // Enhanced Mandelbrot calculation with smooth coloring
            function mandelbrot(x, y) {
                let real = x;
                let imag = y;
                let iterations = 0;
                
                while (iterations < maxIterations && (real * real + imag * imag) <= 4) {
                    const realNew = real * real - imag * imag + x;
                    const imagNew = 2 * real * imag + y;
                    
                    real = realNew;
                    imag = imagNew;
                    iterations++;
                }
                
                // Smooth coloring using escape time algorithm
                if (iterations < maxIterations) {
                    const logZn = Math.log(real * real + imag * imag) / 2;
                    const nu = Math.log(logZn / Math.log(2)) / Math.log(2);
                    return iterations + 1 - nu;
                }
                
                return iterations;
            }

            // Enhanced Julia set calculation with smooth coloring
            function julia(x, y, cReal = juliaC.real, cImag = juliaC.imag) {
                let real = x;
                let imag = y;
                let iterations = 0;
                
                while (iterations < maxIterations && (real * real + imag * imag) <= 4) {
                    const realNew = real * real - imag * imag + cReal;
                    const imagNew = 2 * real * imag + cImag;
                    
                    real = realNew;
                    imag = imagNew;
                    iterations++;
                }
                
                // Smooth coloring
                if (iterations < maxIterations) {
                    const logZn = Math.log(real * real + imag * imag) / 2;
                    const nu = Math.log(logZn / Math.log(2)) / Math.log(2);
                    return iterations + 1 - nu;
                }
                
                return iterations;
            }

            // Enhanced color mapping with smooth gradients
            function getColor(iterations, palette) {
                if (iterations >= maxIterations) return [0, 0, 0]; // Return RGB array for performance
                
                const t = Math.min(1, iterations / maxIterations);
                const smoothT = Math.sin(t * Math.PI * 0.5); // Smooth transition
                
                switch (palette) {
                    case 'cardinal':
                        return [
                            Math.floor(20 + smoothT * 220 + Math.sin(t * 6) * 30),
                            Math.floor(10 + smoothT * 100 + Math.sin(t * 8) * 20),
                            Math.floor(10 + smoothT * 100 + Math.sin(t * 10) * 20)
                        ];
                    
                    case 'rainbow':
                        const hue = (t * 360 + Math.sin(t * 4) * 30) % 360;
                        const [r, g, b] = hslToRgb(hue, 100, 50 + Math.sin(t * 3) * 20);
                        return [Math.floor(r), Math.floor(g), Math.floor(b)];
                    
                    case 'blue':
                        return [
                            Math.floor(smoothT * 150 + Math.sin(t * 5) * 50),
                            Math.floor(50 + smoothT * 200 + Math.sin(t * 7) * 30),
                            Math.floor(100 + smoothT * 155 + Math.sin(t * 9) * 25)
                        ];
                    
                    case 'fire':
                        return [
                            Math.floor(80 + smoothT * 175 + Math.sin(t * 4) * 40),
                            Math.floor(smoothT * 150 + Math.sin(t * 6) * 30),
                            Math.floor(smoothT * 80 + Math.sin(t * 8) * 20)
                        ];
                    
                    default:
                        const gray = Math.floor(smoothT * 255);
                        return [gray, gray, gray];
                }
            }
            
            // HSL to RGB conversion helper
            function hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h * 6) % 2 - 1));
                const m = l - c / 2;
                
                let r, g, b;
                if (h < 1/6) [r, g, b] = [c, x, 0];
                else if (h < 2/6) [r, g, b] = [x, c, 0];
                else if (h < 3/6) [r, g, b] = [0, c, x];
                else if (h < 4/6) [r, g, b] = [0, x, c];
                else if (h < 5/6) [r, g, b] = [x, 0, c];
                else [r, g, b] = [c, 0, x];
                
                return [(r + m) * 255, (g + m) * 255, (b + m) * 255];
            }

            // Optimized rendering with progressive loading
            function render() {
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                const fractalType = document.getElementById('fractalType').value;
                const palette = document.getElementById('colorPalette').value;
                maxIterations = parseInt(document.getElementById('maxIterations').value);
                
                // Calculate scale and offset for mapping pixels to complex plane
                const scale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                const offsetX = centerX - (canvas.width * scale) / 2;
                const offsetY = centerY - (canvas.height * scale) / 2;
                
                // Render in chunks for better performance
                let pixelCount = 0;
                const totalPixels = canvas.width * canvas.height;
                
                const renderChunk = () => {
                    const chunkSize = Math.min(2000, totalPixels - pixelCount);
                    
                    for (let i = 0; i < chunkSize; i++) {
                        const px = pixelCount % canvas.width;
                        const py = Math.floor(pixelCount / canvas.width);
                        
                        const x = offsetX + px * scale;
                        const y = offsetY + py * scale;
                        
                        let iterations;
                        if (fractalType === 'mandelbrot') {
                            iterations = mandelbrot(x, y);
                        } else {
                            iterations = julia(x, y);
                        }
                        
                        const [r, g, b] = getColor(iterations, palette);
                        const index = pixelCount * 4;
                        
                        data[index] = r;     // Red
                        data[index + 1] = g; // Green  
                        data[index + 2] = b; // Blue
                        data[index + 3] = 255; // Alpha
                        
                        pixelCount++;
                    }
                    
                    // Update canvas with current progress
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Update progress info
                    const progress = (pixelCount / totalPixels * 100).toFixed(1);
                    document.getElementById('fractalInfo').innerHTML = 
                        `Rendering: ${progress}% | Zoom: ${zoom.toFixed(2)}x | Iterations: ${maxIterations}<br>Click to zoom in | Shift+Click to zoom out | Drag to pan`;
                    
                    if (pixelCount < totalPixels) {
                        requestAnimationFrame(renderChunk);
                    } else {
                        // Rendering complete
                        document.getElementById('fractalInfo').innerHTML = 
                            `Zoom: ${zoom.toFixed(2)}x | Iterations: ${maxIterations}<br>Click to zoom in | Shift+Click to zoom out | Drag to pan`;
                    }
                };
                
                renderChunk();
            }

            // Enhanced mouse interaction with zoom, pan, and Julia interaction
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (e.button === 0) { // Left click
                    if (e.shiftKey) {
                        // Shift+Click to zoom out
                        zoom = Math.max(0.001, zoom / 2);
                        render();
                    } else {
                        // Start dragging
                        isDragging = true;
                        dragStartX = x;
                        dragStartY = y;
                        lastCenterX = centerX;
                        lastCenterY = centerY;
                        canvas.style.cursor = 'grabbing';
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (isDragging) {
                    // Pan the fractal
                    const scale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                    const dx = (x - dragStartX) * scale;
                    const dy = (y - dragStartY) * scale;
                    
                    centerX = lastCenterX - dx;
                    centerY = lastCenterY - dy;
                    
                    render();
                } else if (document.getElementById('fractalType').value === 'julia') {
                    // Interactive Julia set - mouse position controls the c parameter
                    const scale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                    const mouseX = (x - canvas.width / 2) * scale;
                    const mouseY = (y - canvas.height / 2) * scale;
                    
                    // Map mouse position to Julia constant
                    juliaC.real = (mouseX / canvas.width) * 4 - 2;
                    juliaC.imag = (mouseY / canvas.height) * 4 - 2;
                    
                    // Debounce rendering for smoother interaction
                    clearTimeout(juliaC.renderTimeout);
                    juliaC.renderTimeout = setTimeout(render, 50);
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0 && !e.shiftKey && !isDragging) {
                    // Click to zoom in
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const scale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                    const clickX = centerX - (canvas.width * scale) / 2 + x * scale;
                    const clickY = centerY - (canvas.height * scale) / 2 + y * scale;
                    
                    centerX = clickX;
                    centerY = clickY;
                    zoom *= 2;
                    
                    render();
                }
                
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            });
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const scale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                const mouseX = centerX - (canvas.width * scale) / 2 + x * scale;
                const mouseY = centerY - (canvas.height * scale) / 2 + y * scale;
                
                const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
                zoom = Math.max(0.001, Math.min(1000000, zoom * zoomFactor));
                
                // Keep mouse position fixed during zoom
                const newScale = 4 / (zoom * Math.min(canvas.width, canvas.height));
                centerX = mouseX + (canvas.width * newScale) / 2 - x * newScale;
                centerY = mouseY + (canvas.height * newScale) / 2 - y * newScale;
                
                render();
            });

            // Initial render
            render();

            fractalSystem = {
                render,
                canvas,
                ctx,
                reset: () => {
                    centerX = -0.5;
                    centerY = 0;
                    zoom = 1;
                    juliaC = { real: -0.7, imag: 0.27015 };
                    render();
                },
                save: () => {
                    const link = document.createElement('a');
                    link.download = `fractal-${Date.now()}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                },
                setJuliaC: (real, imag) => {
                    juliaC.real = real;
                    juliaC.imag = imag;
                    if (document.getElementById('fractalType').value === 'julia') {
                        render();
                    }
                },
                getZoom: () => zoom,
                getCenter: () => ({ x: centerX, y: centerY }),
                setView: (cx, cy, z) => {
                    centerX = cx;
                    centerY = cy;
                    zoom = z;
                    render();
                }
            };
        }

        function updateFractals() {
            document.getElementById('maxIterationsValue').textContent = document.getElementById('maxIterations').value;
            if (fractalSystem) {
                fractalSystem.render();
            }
        }

        function resetFractal() {
            if (fractalSystem) {
                fractalSystem.reset();
            }
        }

        function saveFractal() {
            if (fractalSystem) {
                fractalSystem.save();
            }
        }

        // SOUND VISUALIZER EXPERIMENT
        let audioSystem = null;

        function initAudioVisualizer() {
            const canvas = document.getElementById('audioCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            let audioContext;
            let analyser;
            let microphone;
            let dataArray;
            let animationId;
            let isCapturing = false;

            audioSystem = {
                isCapturing: () => isCapturing,
                stop: () => {
                    if (microphone) {
                        microphone.getTracks().forEach(track => track.stop());
                    }
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    isCapturing = false;
                }
            };
        }

        function startAudioCapture() {
            if (!audioSystem) return;
            
            if (audioSystem.isCapturing()) {
                audioSystem.stop();
                document.getElementById('audioToggleBtn').textContent = 'Start Microphone';
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    const canvas = document.getElementById('audioCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    
                    microphone.connect(analyser);
                    
                    function visualize() {
                        analyser.getByteFrequencyData(dataArray);
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        const visualizationType = document.getElementById('visualizationType').value;
                        const sensitivity = parseFloat(document.getElementById('audioSensitivity').value);
                        
                        switch (visualizationType) {
                            case 'bars':
                                drawFrequencyBars(ctx, canvas, dataArray, sensitivity);
                                break;
                            case 'circular':
                                drawCircularVisualizer(ctx, canvas, dataArray, sensitivity);
                                break;
                            case 'waveform':
                                drawWaveform(ctx, canvas, dataArray, sensitivity);
                                break;
                            case 'particles':
                                drawParticleField(ctx, canvas, dataArray, sensitivity);
                                break;
                        }
                        
                        requestAnimationFrame(visualize);
                    }
                    
                    visualize();
                    document.getElementById('audioToggleBtn').textContent = 'Stop Microphone';
                    
                    audioSystem = {
                        ...audioSystem,
                        stream,
                        audioContext,
                        isCapturing: () => true,
                        stop: () => {
                            stream.getTracks().forEach(track => track.stop());
                            audioContext.close();
                            document.getElementById('audioToggleBtn').textContent = 'Start Microphone';
                        }
                    };
                })
                .catch(err => {
                    console.error('Error accessing microphone:', err);
                    alert('Could not access microphone. Please ensure microphone permissions are granted.');
                });
        }

        function drawFrequencyBars(ctx, canvas, dataArray, sensitivity) {
            const barWidth = canvas.width / dataArray.length * 2;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height * sensitivity;
                
                const red = Math.floor((i / dataArray.length) * 255);
                const green = Math.floor((barHeight / canvas.height) * 255);
                const blue = 100;
                
                ctx.fillStyle = `rgb(${red},${green},${blue})`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }

        function drawCircularVisualizer(ctx, canvas, dataArray, sensitivity) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 4;
            
            ctx.strokeStyle = '#8C1515';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < dataArray.length; i++) {
                const angle = (i / dataArray.length) * Math.PI * 2;
                const amplitude = (dataArray[i] / 255) * radius * sensitivity;
                
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + amplitude);
                const y2 = centerY + Math.sin(angle) * (radius + amplitude);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        function drawWaveform(ctx, canvas, dataArray, sensitivity) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#006CB8';
            ctx.beginPath();
            
            const sliceWidth = canvas.width / dataArray.length;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                const v = (dataArray[i] / 255) * sensitivity;
                const y = v * canvas.height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }

        function drawParticleField(ctx, canvas, dataArray, sensitivity) {
            for (let i = 0; i < dataArray.length; i += 4) {
                const amplitude = dataArray[i] / 255 * sensitivity;
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = amplitude * 20;
                
                if (amplitude > 0.1) {
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(140, 21, 21, ${amplitude})`;
                    ctx.fill();
                }
            }
        }

        function updateAudioVisualizer() {
            document.getElementById('audioSensitivityValue').textContent = document.getElementById('audioSensitivity').value;
            document.getElementById('audioSmoothingValue').textContent = document.getElementById('audioSmoothing').value;
        }

        function generateTestTone() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 440; // A4 note
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1);
        }

        function stopAudioCapture() {
            if (audioSystem) {
                audioSystem.stop();
            }
        }

        // 3D PLAYGROUND EXPERIMENT
        let scene3D = null;

        function init3DScene() {
            const container = document.getElementById('threejsContainer');
            
            // Initialize Three.js scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setClearColor(0x000000);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create initial shape
            let currentMesh;
            createShape();
            
            camera.position.z = 5;
            
            // Mouse controls
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            
            container.addEventListener('mousemove', (event) => {
                const rect = container.getBoundingClientRect();
                mouseX = (event.clientX - rect.left) / container.offsetWidth * 2 - 1;
                mouseY = -(event.clientY - rect.top) / container.offsetHeight * 2 + 1;
                
                targetRotationX = mouseY * 0.5;
                targetRotationY = mouseX * 0.5;
            });
            
            function createShape() {
                if (currentMesh) {
                    scene.remove(currentMesh);
                }
                
                const shapeType = document.getElementById('shapeType').value;
                const wireframe = document.getElementById('wireframeMode').checked;
                const colorType = document.getElementById('shapeColor').value;
                
                let geometry;
                switch (shapeType) {
                    case 'cube':
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1.5, 32, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(1, 0.5, 16, 100);
                        break;
                    case 'icosahedron':
                        geometry = new THREE.IcosahedronGeometry(1.5, 0);
                        break;
                    case 'multiple':
                        createMultipleShapes();
                        return;
                }
                
                let color;
                switch (colorType) {
                    case 'cardinal':
                        color = 0x8C1515;
                        break;
                    case 'blue':
                        color = 0x006CB8;
                        break;
                    case 'green':
                        color = 0x009B76;
                        break;
                    case 'rainbow':
                        color = Math.random() * 0xffffff;
                        break;
                    default:
                        color = 0x8C1515;
                }
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    wireframe: wireframe
                });
                
                currentMesh = new THREE.Mesh(geometry, material);
                scene.add(currentMesh);
            }
            
            function createMultipleShapes() {
                const shapes = [
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.SphereGeometry(0.7, 16, 16),
                    new THREE.TorusGeometry(0.7, 0.3, 8, 50)
                ];
                
                const colors = [0x8C1515, 0x006CB8, 0x009B76];
                
                for (let i = 0; i < shapes.length; i++) {
                    const material = new THREE.MeshPhongMaterial({
                        color: colors[i],
                        wireframe: document.getElementById('wireframeMode').checked
                    });
                    
                    const mesh = new THREE.Mesh(shapes[i], material);
                    mesh.position.x = (i - 1) * 2;
                    scene.add(mesh);
                }
                
                currentMesh = null; // Multiple objects, can't track single mesh
            }
            
            function animate() {
                requestAnimationFrame(animate);
                
                const rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
                
                if (currentMesh) {
                    // Smooth rotation towards mouse position
                    currentMesh.rotation.x += (targetRotationX - currentMesh.rotation.x) * 0.05;
                    currentMesh.rotation.y += (targetRotationY - currentMesh.rotation.y) * 0.05;
                    
                    // Auto rotation
                    currentMesh.rotation.x += rotationSpeed;
                    currentMesh.rotation.y += rotationSpeed;
                } else {
                    // Multiple shapes
                    scene.children.forEach((child, index) => {
                        if (child instanceof THREE.Mesh) {
                            child.rotation.x += rotationSpeed * (1 + index * 0.5);
                            child.rotation.y += rotationSpeed * (1 + index * 0.3);
                        }
                    });
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            scene3D = {
                scene,
                camera,
                renderer,
                container,
                createShape,
                reset: () => {
                    camera.position.set(0, 0, 5);
                    camera.lookAt(0, 0, 0);
                },
                cleanup: () => {
                    if (renderer.domElement.parentNode) {
                        renderer.domElement.parentNode.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                }
            };
        }

        function update3DScene() {
            if (scene3D) {
                scene3D.createShape();
            }
            document.getElementById('rotationSpeedValue').textContent = document.getElementById('rotationSpeed').value;
        }

        function reset3DScene() {
            if (scene3D) {
                scene3D.reset();
            }
        }

        function randomize3DScene() {
            const shapes = ['cube', 'sphere', 'torus', 'icosahedron', 'multiple'];
            const colors = ['cardinal', 'blue', 'green', 'rainbow'];
            
            document.getElementById('shapeType').value = shapes[Math.floor(Math.random() * shapes.length)];
            document.getElementById('shapeColor').value = colors[Math.floor(Math.random() * colors.length)];
            document.getElementById('rotationSpeed').value = (Math.random() * 0.05 + 0.005).toFixed(3);
            document.getElementById('wireframeMode').checked = Math.random() > 0.5;
            
            update3DScene();
        }

        function cleanup3DScene() {
            if (scene3D) {
                scene3D.cleanup();
                scene3D = null;
            }
        }

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const navLinks = document.getElementById('navLinks');

        menuToggle.addEventListener('click', () => {
            menuToggle.classList.toggle('active');
            navLinks.classList.toggle('active');
        });

        // Close mobile menu when clicking a link
        navLinks.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                menuToggle.classList.remove('active');
                navLinks.classList.remove('active');
            });
        });

        // Smooth reveal animations on scroll
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.animationPlayState = 'running';
                }
            });
        }, observerOptions);

        // Observe experiment cards
        document.querySelectorAll('.experiment').forEach(experiment => {
            experiment.style.animationPlayState = 'paused';
            observer.observe(experiment);
        });
    </script>
</body>
</html>